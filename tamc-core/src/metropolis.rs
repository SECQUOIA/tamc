use std::marker::PhantomData;
use crate::traits::{State, Instance, Sampler, MacroSampler, MarkovChain};
use num_traits::{Num, Zero};
use num_traits::real::Real;
use rand::Rng;
use rand::distributions::{Distribution, Standard};
use rand::distributions::uniform::{SampleUniform, Uniform};

/// A Markov Chain generated by a distribution of random move proposals independent of the current
/// state accepted according to the Metropolis-Hastings algorithm
#[derive(Clone)]
pub struct MetropolisSampler<R: Real, N, D: Distribution<N>>{
    pub beta: R,
    rand_distr: D,
    _phantom: PhantomData<N>
}

impl<R: Real, N> MetropolisSampler<R, N, Uniform<N>>
    where N: Num + SampleUniform
{
    pub fn new_uniform(beta: R, n: N) -> Self{
        let rand_int = Uniform::new(N::zero(), n);
        Self{beta, rand_distr: rand_int, _phantom: PhantomData}
    }
}

// impl<R: Real, N, D: Distribution<N>, I: Instance, Rn: Rng+?Sized> MarkovChain<I, Rn> for MetropolisSampler<R, N, D>
//     where I::St: State<Move=N>
// {
//     fn propose_move(&self, _: &I, _: &I::St, rng: &mut Rn) -> N{
//         return rng.sample(&self.rand_distr);
//     }
// }

impl<I, N, D: Distribution<N>, Rn: Rng+?Sized> Sampler<I, Rn> for MetropolisSampler<I::Energy, N, D>
    where I: Instance, I::St: State<Move=N>, Standard: Distribution<I::Energy>, I::Energy: Real
{
    type SampleType = I::St;
    //type ParamType = I::Param;

    fn advance(&self, state: &mut I::St, instance: &I, rng: &mut Rn) {
        let mv = rng.sample(&self.rand_distr);
        let delta_e = unsafe { instance.delta_energy( &*state, &mv) };
        if delta_e < <I::Energy as Zero>::zero(){
            state.accept_move(mv);
        } else {
            let p = Real::exp(-self.beta * delta_e);
            let x: I::Energy = rng.sample(Standard);
            if x < p{
                state.accept_move(mv)
            }
        }
    }
}


impl< I, N, D: Distribution<N>, Rn: Rng+?Sized> MacroSampler<I, Rn> for MetropolisSampler<I::Energy, N, D>
    where I: Instance, I::St: State<Move=N>, Standard: Distribution<I::Energy>
{
    fn beta(&self) -> I::Energy {
        return self.beta;
    }
    fn energy(&self, instance: &I, st: &I::St) -> I::Energy{
        return  instance.energy(st);
    }
}
