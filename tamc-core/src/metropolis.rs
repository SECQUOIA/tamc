use std::marker::PhantomData;
use crate::traits::*;
use num_traits::{Num, Zero};
use num_traits::FromPrimitive;
use num_traits::real::Real;
use rand::Rng;
use rand::distributions::{Distribution, Standard};
use rand::distributions::uniform::{SampleUniform, Uniform};

/// A Markov Chain generated by a distribution of random move proposals independent of the current
/// state accepted according to the Metropolis-Hastings algorithm
#[derive(Clone)]
pub struct MetropolisSampler<'a, R, N, St: State<N>, I: Instance<N, St>, D: Distribution<N>>{
    pub beta: R,
    pub rand_distr: D,
    pub instance: &'a I,
    _phantom: PhantomData<(St, N)>
}

impl<'a, R: Real, N, St: State<N>, I: Instance<N, St> > MetropolisSampler<'a, R, N, St, I, Uniform<N>>
    where N: Num + SampleUniform
{
    pub fn new_uniform(instance: &'a I, beta: R, n: N) -> Self{
        let rand_int = Uniform::new(N::zero(), n);
        Self{beta, rand_distr: rand_int, instance, _phantom: PhantomData}
    }
}

// impl<R: Real, N, D: Distribution<N>, I: Instance, Rn: Rng+?Sized> MarkovChain<I, Rn> for MetropolisSampler<R, N, D>
//     where I::St: State<Move=N>
// {
//     fn propose_move(&self, _: &I, _: &I::St, rng: &mut Rn) -> N{
//         return rng.sample(&self.rand_distr);
//     }
// }
impl<'a, R, N, St, I, D: Distribution<N>>
MetropolisSampler<'a, R, N, St, I, D>
    where   I: Instance<N, St, Energy=R>,
            St: State<N>,
            Standard: Distribution<R>,
            R: Real
{
    pub fn advance_impl<Rn: Rng+?Sized>(&self, mv: N, state: &mut St, rng: &mut Rn) -> Option<R>{
        let delta_e = unsafe { self.instance.delta_energy( state, &mv) };
        if delta_e < <I::Energy as Zero>::zero(){
            state.accept_move(mv);
            return Some(delta_e);
        } else {
            let p = Real::exp(-self.beta * delta_e);
            let x: I::Energy = rng.sample(Standard);
            if x < p{
                state.accept_move(mv);
                return Some(delta_e);
            }
        }
        return None;
    }
}


impl<'a, R, N, St, I, D: Distribution<N>, Rn: Rng+?Sized> Sampler<Rn>
for MetropolisSampler<'a, R, N, St, I, D>
where   I: Instance<N, St, Energy=R>,
        St: State<N>,
        Standard: Distribution<R>,
        R: Real,
        N: Num + FromPrimitive
{
    type SampleType = St;
    //type ParamType = I::Param;

    fn advance(&self, state: &mut St, rng: &mut Rn) {
        let mv = rng.sample(&self.rand_distr);
        self.advance_impl(mv, state, rng);
    }

    fn sweep(&self, state: &mut St, rng: &mut Rn){
        let n = self.instance.size();
        for i in 0..n{
            let mv = N::from_usize(i).unwrap();
            self.advance_impl(mv, state, rng);
        }
    }
}

impl<'a, R, N, St, I, D: Distribution<N>> Macrostate<R>
for MetropolisSampler<'a, R, N, St, I, D>
where   I: Instance<N, St, Energy=R>,
        St: State<N>,
        Standard: Distribution<R>,
        R: Real{
    type Microstate = St;

    fn beta(&self) -> R {
        return self.beta;
    }

    fn energy(&self, st: &mut St) -> R {
        return self.instance.energy(st);
    }
}

//
// impl<N, St, I, D: Distribution<N>, Rn: Rng+?Sized> GenericSampler<N, St, I, Rn> for MetropolisSampler<I::Energy, N, D>
//     where I: Instance<N, St>, St: State<N>, Standard: Distribution<I::Energy>, I::Energy: Real
// {
//     type SampleType = St;
//     //type ParamType = I::Param;
//
//     fn advance(&self, state: &mut St, instance: &I, rng: &mut Rn) {
//         let mv = rng.sample(&self.rand_distr);
//         let delta_e = unsafe { instance.delta_energy( &*state, &mv) };
//         if delta_e < <I::Energy as Zero>::zero(){
//             state.accept_move(mv);
//         } else {
//             let p = Real::exp(-self.beta * delta_e);
//             let x: I::Energy = rng.sample(Standard);
//             if x < p{
//                 state.accept_move(mv)
//             }
//         }
//     }
// }
//
//
// impl<N, St, I, D: Distribution<N>, Rn: Rng+?Sized> GenericMacroSampler<N, St, I, Rn> for MetropolisSampler<I::Energy, N, D>
//     where I: Instance<N, St>, St: State<N>, Standard: Distribution<I::Energy>
// {
//     fn beta(&self) -> I::Energy {
//         return self.beta;
//     }
//     fn energy(&self, instance: &I, st: &St) -> I::Energy{
//         return  instance.energy(st);
//     }
// }
